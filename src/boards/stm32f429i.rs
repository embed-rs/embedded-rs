use ::base::volatile::VolatileStruct;
use ::components::*;
use ::InterruptHandler;

#[repr(C)]
pub struct VectorTable {
    pub msp: &'static (),
    pub reset: Option<InterruptHandler>,
    pub nmi: Option<InterruptHandler>,
    pub hard_fault: Option<InterruptHandler>,
    pub mem_manage: Option<InterruptHandler>,
    pub bus_fault: Option<InterruptHandler>,
    pub usage_fault: Option<InterruptHandler>,
    pub _reserved7: Option<InterruptHandler>,
    pub _reserved8: Option<InterruptHandler>,
    pub _reserved9: Option<InterruptHandler>,
    pub _reserved10: Option<InterruptHandler>,
    pub svc: Option<InterruptHandler>,
    pub debug_monitor: Option<InterruptHandler>,
    pub _reserved13: Option<InterruptHandler>,
    pub pend_sv: Option<InterruptHandler>,
    pub sys_tick: Option<InterruptHandler>,
    pub interrupt0: Option<InterruptHandler>,
    pub interrupt1: Option<InterruptHandler>,
    pub interrupt2: Option<InterruptHandler>,
    pub interrupt3: Option<InterruptHandler>,
    pub interrupt4: Option<InterruptHandler>,
    pub interrupt5: Option<InterruptHandler>,
    pub interrupt6: Option<InterruptHandler>,
    pub interrupt7: Option<InterruptHandler>,
    pub interrupt8: Option<InterruptHandler>,
    pub interrupt9: Option<InterruptHandler>,
}

pub const VECTOR_TABLE: VectorTable = VectorTable {
    msp: &(),
    reset: None,
    nmi: None,
    hard_fault: None,
    mem_manage: None,
    bus_fault: None,
    usage_fault: None,
    _reserved7: None,
    _reserved8: None,
    _reserved9: None,
    _reserved10: None,
    svc: None,
    debug_monitor: None,
    _reserved13: None,
    pend_sv: None,
    sys_tick: None,
    interrupt0: None,
    interrupt1: None,
    interrupt2: None,
    interrupt3: None,
    interrupt4: None,
    interrupt5: None,
    interrupt6: None,
    interrupt7: None,
    interrupt8: None,
    interrupt9: None,
};

#[allow(unused)]
pub const INITIAL_CPU_FREQ: usize = 8_000_000;


// an incomplete Hardware struct
// not autogenerated yet, but we can fill that in later
pub struct Hardware {
    pub gpio_a: &'static mut gpio::GpioBank<gpio::PortA>,
    pub gpio_b: &'static mut gpio::GpioBank<gpio::PortB>,
    pub gpio_c: &'static mut gpio::GpioBank<gpio::PortC>,
    pub gpio_d: &'static mut gpio::GpioBank<gpio::PortD>,
    pub gpio_e: &'static mut gpio::GpioBank<gpio::PortE>,
    pub gpio_f: &'static mut gpio::GpioBank<gpio::PortF>,
    pub gpio_g: &'static mut gpio::GpioBank<gpio::PortG>,
    pub gpio_h: &'static mut gpio::GpioBank<gpio::PortH>,
    pub gpio_i: &'static mut gpio::GpioBank<gpio::PortI>,
    pub gpio_j: &'static mut gpio::GpioBank<gpio::PortJ>,
    pub gpio_k: &'static mut gpio::GpioBank<gpio::PortK>,
    pub rcc: &'static mut rcc::RccBank,
}

pub unsafe fn hw() -> Hardware {
    Hardware {
        gpio_a: gpio::GpioBank::from_addr(0x40020000),
        gpio_b: gpio::GpioBank::from_addr(0x40020400),
        gpio_c: gpio::GpioBank::from_addr(0x40020800),
        gpio_d: gpio::GpioBank::from_addr(0x40020C00),
        gpio_e: gpio::GpioBank::from_addr(0x40021000),
        gpio_f: gpio::GpioBank::from_addr(0x40021400),
        gpio_g: gpio::GpioBank::from_addr(0x40021800),
        gpio_h: gpio::GpioBank::from_addr(0x40021C00),
        gpio_i: gpio::GpioBank::from_addr(0x40022000),
        gpio_j: gpio::GpioBank::from_addr(0x40022400),
        gpio_k: gpio::GpioBank::from_addr(0x40022800),
        rcc: rcc::RccBank::from_addr(0x40023800),
    }
}
